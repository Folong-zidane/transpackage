

import { StyleSheet,Button, Text, View } from "react-native";
import { ScrollView, StatusBar, TouchableOpacity, Image } from 'react-native';

export default function TestScreen() {
  return (
    <View style={styles.container}>
        
      <View style={styles.main}>
        <Text style={styles.title}>Hello World (Test)</Text>
        <Text style={styles.subtitle}>This is the first page for test your app.</Text>
        <View style={styles.buttonContainer}>
            <Button title="Test" onPress={() => console.log('Test est cliqu√©')} />
        </View>

      </View>
    </View>
  );
} 

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: "center",
    padding: 24,
  },
  main: {
    flex: 1,
    justifyContent: "center",
    maxWidth: 960,
    marginHorizontal: "auto",
  },
  title: {
    fontSize: 50,
    fontWeight: "bold",
  },
  subtitle: {
    fontSize: 36,
    color: "#38434D",
  },
  buttonContainer: {
    alignSelf: 'center',
    width: '50%',
    color: '#555',
    fontWeight: 'bold',
    margin: 10,
    backgroundColor: 'orange',
    padding: 15,
    borderRadius: 10,
    alignItems: 'center',
  },

});















// le code du context notification qui est dans le dossier d'origine est le suivant :

import type React from "react"
import { createContext, useState, useContext, useEffect } from "react"
import AsyncStorage from "@react-native-async-storage/async-storage"
import { usePackages } from "./PackageContext"

export interface Notification {
  id: string
  title: string
  message: string
  type: "info" | "success" | "warning" | "error"
  read: boolean
  createdAt: Date
  packageId?: string
  relayPointId?: string
}

interface NotificationContextType {
  notifications: Notification[]
  unreadCount: number
  addNotification: (notification: Omit<Notification, "id" | "read" | "createdAt">) => void
  markAsRead: (id: string) => void
  markAllAsRead: () => void
  clearNotifications: () => void
}

const NotificationContext = createContext<NotificationContextType | undefined>(undefined)

export const useNotifications = () => {
  const context = useContext(NotificationContext)
  if (!context) {
    throw new Error("useNotifications must be used within a NotificationProvider")
  }
  return context
}

export const NotificationProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [notifications, setNotifications] = useState<Notification[]>([])
  const { packages } = usePackages()

  // Charger les notifications depuis le stockage local au d√©marrage
  useEffect(() => {
    const loadNotifications = async () => {
      try {
        const storedNotifications = await AsyncStorage.getItem("notifications")
        if (storedNotifications) {
          const parsedNotifications = JSON.parse(storedNotifications)
          // Convertir les cha√Ænes de date en objets Date
          const formattedNotifications = parsedNotifications.map((notif: any) => ({
            ...notif,
            createdAt: new Date(notif.createdAt),
          }))
          setNotifications(formattedNotifications)
        }
      } catch (error) {
        console.error("Failed to load notifications", error)
      }
    }

    loadNotifications()
  }, [])

  // Surveiller les changements de statut des colis pour cr√©er des notifications
  useEffect(() => {
    // Cette logique serait normalement g√©r√©e par un backend avec des webhooks ou des push notifications
    // Ici, nous simulons ce comportement pour la d√©monstration
  }, [packages])

  // Sauvegarder les notifications dans le stockage local √† chaque changement
  useEffect(() => {
    const saveNotifications = async () => {
      try {
        await AsyncStorage.setItem("notifications", JSON.stringify(notifications))
      } catch (error) {
        console.error("Failed to save notifications", error)
      }
    }

    if (notifications.length > 0) {
      saveNotifications()
    }
  }, [notifications])

  const addNotification = (notificationData: Omit<Notification, "id" | "read" | "createdAt">) => {
    const newNotification: Notification = {
      ...notificationData,
      id: Math.random().toString(36).substring(2, 9),
      read: false,
      createdAt: new Date(),
    }

    setNotifications((prev) => [newNotification, ...prev])

    // Dans une vraie application, vous enverriez une notification push ici
    console.log("Nouvelle notification:", newNotification.title)
  }

  const markAsRead = (id: string) => {
    setNotifications((prev) =>
      prev.map((notification) => (notification.id === id ? { ...notification, read: true } : notification)),
    )
  }

  const markAllAsRead = () => {
    setNotifications((prev) => prev.map((notification) => ({ ...notification, read: true })))
  }

  const clearNotifications = () => {
    setNotifications([])
    AsyncStorage.removeItem("notifications")
  }

  const unreadCount = notifications.filter((notification) => !notification.read).length

  return (
    <NotificationContext.Provider
      value={{
        notifications,
        unreadCount,
        addNotification,
        markAsRead,
        markAllAsRead,
        clearNotifications,
      }}
    >
      {children}
    </NotificationContext.Provider>
  )
}















Cr√©er une application mobile intuitive et fluide avec React Native Expo pour la gestion des colis n√©cessite une bonne structure, une exp√©rience utilisateur pens√©e, et une architecture propre. Voici un guide √©tape par √©tape pour concevoir cette application, en abordant chaque fonctionnalit√© que tu as list√©e :

---

### üîß Outils n√©cessaires

* React Native (via Expo)
* TypeScript (optionnel mais recommand√©)
* React Navigation
* React Native Maps
* Firebase ou Supabase pour backend
* Zustand ou Redux pour gestion d‚Äô√©tat
* Tailwind CSS via NativeWind ou StyleSheet
* Lottie ou React Native Animatable pour les animations fluides

---

## üß± Structure g√©n√©rale de l‚Äôapp

### 1. Authentification (client simple ou agence)

* Choix du r√¥le √† la connexion (client simple ou agence)
* Auth via e-mail/password ou OTP

### 2. Navigation

* TabNavigator (Accueil, Envoyer, R√©ception, Carte, Profil)
* StackNavigator pour les d√©tails

---

## üéØ Fonctionnalit√©s principales

### üìç Afficher les points relais

* Carte avec markers via react-native-maps
* Liste des points avec infos essentielles (nom, disponibilit√©, horaires)
* Bouton "Voir sur la carte" ‚Üí navigue vers une map centr√©e

```tsx
<Button title="Voir sur la carte" onPress={() => navigation.navigate("Carte", { idPointRelais })} />
```

### üí° UX Design : Couleurs

* Couleurs chaudes pour les actions (orange/rouge pour "envoyer")
* Couleurs calmes (bleu/vert) pour la r√©ception
* Couleurs d√©satur√©es pour les points relais d√©sactiv√©s
* Ic√¥nes explicites (üì¶ pour colis, ‚è∞ pour horaires, üìç pour localisation)

---

### üìã D√©tail d‚Äôun point relais (Profil)

Contenu :

* Nom
* Adresse
* Horaires d‚Äôouverture
* Carte (mini-map)
* Image du lieu
* Statistiques (nb de colis trait√©s)
* Bouton pour changer de point relais si d√©sactiv√©

---

### üîÑ Deux types d‚Äôutilisateurs

* Client :

  * Envoie/re√ßoit des colis
  * Choisit point relais
* Agence :

  * Cr√©e/active/d√©sactive des points relais
  * Acc√®de aux statistiques

---

### üì¶ Gestion des colis

* Formulaire : poids, volume, description
* √Ä l‚Äôenvoi ‚Üí g√©n√©rer un identifiant unique (UUID ou bas√© sur timestamp + user ID)

```ts
import { v4 as uuidv4 } from 'uuid'
const colisId = uuidv4()
```

* Associer le colis au client et au point relais

---

## üéõÔ∏è Interface fluide

* Utiliser FlatList avec optimisations
* Skeleton loaders pendant le chargement
* Transitions anim√©es entre les vues
* Retours haptiques sur les boutons

---

## ‚úÖ R√©sum√© des composants React √† cr√©er

* HomeScreen
* LoginScreen
* ChoixR√¥leScreen
* EnvoyerColisScreen
* RecevoirColisScreen
* CarteScreen (avec react-native-maps)
* PointRelaisDetailsScreen
* ProfilUtilisateurScreen
* AgenceDashboardScreen (si agence)



Souhaites-tu que je te g√©n√®re une base de projet Expo + quelques √©crans pour d√©marrer rapidement ?

















